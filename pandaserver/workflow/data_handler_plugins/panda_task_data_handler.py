import json
import traceback
import uuid

from pandacommon.pandalogger.LogWrapper import LogWrapper
from pandacommon.pandalogger.PandaLogger import PandaLogger

from pandaserver.dataservice.ddm import rucioAPI
from pandaserver.workflow.data_handler_plugins.base_data_handler import BaseDataHandler
from pandaserver.workflow.workflow_base import (
    WFDataSpec,
    WFDataStatus,
    WFDataTargetCheckResult,
    WFDataTargetCheckStatus,
    WFDataType,
    WFStepSpec,
    WFStepStatus,
    WFStepType,
    WorkflowSpec,
    WorkflowStatus,
)

# main logger
logger = PandaLogger().getLogger(__name__.split(".")[-1])


class DDMCollectionDIDType:
    """
    Data Identifier Types for DDM Collections
    """

    DATASET = "DATASET"
    CONTAINER = "CONTAINER"


class DDMCollectionState:
    """
    States for DDM Collections
    """

    open = "open"
    closed = "closed"
    missing = "missing"


class PandaTaskDataHandler(BaseDataHandler):
    """
    Handler for PanDA task intermediate/output data in the workflow.
    This class is responsible for managing the data generated by PanDA task within a workflow.
    The output data from a PanDA task is usually a DDM container, which remains open even after the task completion.
    Thus, the handler not only checks the status of the DDM collection to determine if there are files available, but also verifies the step status of source workflow steps to ensure that the data generation process has been completed successfully.
    """

    def __init__(self, *args, **kwargs):
        """
        Initialize the data handler with necessary parameters.
        """
        # Initialize base class or any required modules here
        super().__init__(*args, **kwargs)
        self.ddmIF = rucioAPI
        self.plugin_flavor = "panda_task"

    def check_target(self, data_spec: WFDataSpec, **kwargs) -> WFDataTargetCheckResult:
        """
        Check the status of the PanDA task data target.
        This method should be implemented to handle the specifics of PanDA task data status checking.

        Args:
            data_spec (WFDataSpec): The data specification containing details about the data to be checked.
            **kwargs: Additional keyword arguments that may be required for checking.

        Returns:
            WFDataTargetCheckResult: An object containing the result of the check, including success status, current data status, and message.
        """
        tmp_log = LogWrapper(logger, f"check_target workflow_id={data_spec.workflow_id} data_id={data_spec.data_id}")
        # Initialize
        check_result = WFDataTargetCheckResult()
        # Check data flavor
        if data_spec.flavor != self.plugin_flavor:
            tmp_log.warning(f"flavor={data_spec.flavor} not {self.plugin_flavor}; skipped")
            check_result.message = f"flavor not {self.plugin_flavor}; skipped"
            return check_result
        # Check source step status
        if data_spec.source_step_id is not None:
            source_step_spec = self.tbif.get_workflow_step(data_spec.source_step_id)
            if source_step_spec is None:
                check_result.success = False
                check_result.message = f"Failed to get source step step_id={data_spec.source_step_id}; skipped"
                tmp_log.error(f"{check_result.message}")
                return check_result
            if source_step_spec.status == WFStepStatus.done:
                # Source step done; consider data fully available
                check_result.success = True
                check_result.check_status = WFDataTargetCheckStatus.complete
                tmp_log.info(f"Source step step_id={source_step_spec.step_id} done, data considered fully available; check_status={check_result.check_status}")
                return check_result
            elif source_step_spec.status in WFStepStatus.final_statuses:
                # Source step in final status but not done; skip data availability
                check_result.success = True
                check_result.message = f"Source step step_id={source_step_spec.step_id} {source_step_spec.status}; skip data availability check"
                tmp_log.warning(f"{check_result.message}")
                return check_result
            else:
                tmp_log.info(f"Source step step_id={source_step_spec.step_id} status={source_step_spec.status}; checking data availability")
        else:
            tmp_log.info("No source step yet; checking data availability")
        # Without source step or source step not terminated; check number of files in DDM collections
        total_n_files = 0
        none_exist = True
        output_types = data_spec.get_parameter("output_types")
        if output_types is None:
            output_types = []
        for output_type in output_types:
            collection = f"{data_spec.target_id}_{output_type}"
            tmp_stat, tmp_res = self.ddmIF.get_number_of_files(collection)
            if tmp_stat is None:
                tmp_log.debug(f"Collection {collection} does not exist")
            elif not tmp_stat:
                # Error in getting number of files
                check_result.success = False
                check_result.message = f"Failed to get number of files for collection {collection}: {tmp_res}"
                tmp_log.error(f"{check_result.message}")
                return check_result
            else:
                none_exist = False
                n_files = tmp_res
                total_n_files += n_files
                tmp_log.debug(f"Got collection {collection} n_files={n_files}")
        # Check number of files
        if none_exist:
            check_result.check_status = WFDataTargetCheckStatus.nonexist
        elif total_n_files == 0:
            check_result.check_status = WFDataTargetCheckStatus.insuffi
        else:
            # At least 1 file is sufficient for step input
            check_result.check_status = WFDataTargetCheckStatus.suffice
        check_result.success = True
        tmp_log.info(f"Got total_n_files={total_n_files}; check_status={check_result.check_status}")
        return check_result
